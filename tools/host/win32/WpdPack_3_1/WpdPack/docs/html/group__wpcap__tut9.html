<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>WinPcap: Gathering Statistics on the network traffic</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Gathering Statistics on the network traffic<br>
<small>
[<a class="el" href="group__wpcap__tut.html">WinPcap tutorial: a step by step guide to using WinPcap</a>]</small>
</h1><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
</table>
This lesson shows another advanced feature of WinPcap: the ability to collect statistics about network traffic. The statistical engine makes use of the kernel-level packet filter to efficiently classify the incoming packet. You can take a look at the <a class="el" href="group__NPF.html">NPF driver internals manual</a> if you want to know more details.<p>
In order to use this feature, the programmer must open an adapter and put it in <em>statistical</em> <em>mode</em>. This can be done with <a class="el" href="group__wpcapfunc.html#ga48">pcap_setmode()</a>. In particular, MODE_STAT must be used as the <em>mode</em> argument of this function.<p>
With statistical mode, making an application that monitors the TCP traffic load is a matter of few lines of code. The following sample shows how to do it.<p>
<pre><div class="fragment"><span class="comment">/*</span>
<span class="comment"> * Copyright (c) 1999 - 2003</span>
<span class="comment"> * NetGroup, Politecnico di Torino (Italy)</span>
<span class="comment"> * All rights reserved.</span>
<span class="comment"> * </span>
<span class="comment"> * Redistribution and use in source and binary forms, with or without </span>
<span class="comment"> * modification, are permitted provided that the following conditions </span>
<span class="comment"> * are met:</span>
<span class="comment"> * </span>
<span class="comment"> * 1. Redistributions of source code must retain the above copyright </span>
<span class="comment"> * notice, this list of conditions and the following disclaimer.</span>
<span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright </span>
<span class="comment"> * notice, this list of conditions and the following disclaimer in the </span>
<span class="comment"> * documentation and/or other materials provided with the distribution. </span>
<span class="comment"> * 3. Neither the name of the Politecnico di Torino nor the names of its </span>
<span class="comment"> * contributors may be used to endorse or promote products derived from </span>
<span class="comment"> * this software without specific prior written permission. </span>
<span class="comment"> * </span>
<span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS </span>
<span class="comment"> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT </span>
<span class="comment"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR </span>
<span class="comment"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT </span>
<span class="comment"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, </span>
<span class="comment"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT </span>
<span class="comment"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, </span>
<span class="comment"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY </span>
<span class="comment"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT </span>
<span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE </span>
<span class="comment"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="comment"> * </span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="preprocessor">#include &lt;pcap.h&gt;</span>

<span class="keywordtype">void</span> usage();

<span class="keywordtype">void</span> dispatcher_handler(u_char *, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *, <span class="keyword">const</span> u_char *);


<span class="keywordtype">void</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
<a class="code" href="group__wpcap__def.html#ga2">pcap_t</a> *fp;
<span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#ga8">PCAP_ERRBUF_SIZE</a>];
<span class="keyword">struct </span>timeval st_ts;
u_int netmask;
<span class="keyword">struct </span>bpf_program fcode;
  
    <span class="comment">/* Check the validity of the command line */</span>
    <span class="keywordflow">if</span> (argc != 2)
    {
        usage();
        <span class="keywordflow">return</span>;
    }
        
    <span class="comment">/* Open the output adapter */</span>
    <span class="keywordflow">if</span> ( (fp= <a class="code" href="group__wpcapfunc.html#ga58">pcap_open</a>(argv[1], 100, PCAP_OPENFLAG_PROMISCUOUS, 1000, NULL, errbuf) ) == NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nUnable to open adapter %s.\n"</span>, errbuf);
        <span class="keywordflow">return</span>;
    }

    <span class="comment">/* Don't care about netmask, it won't be used for this filter */</span>
    netmask=0xffffff; 

    <span class="comment">//compile the filter</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__wpcapfunc.html#ga19">pcap_compile</a>(fp, &amp;fcode, <span class="stringliteral">"tcp"</span>, 1, netmask) &lt;0 )
    {
        fprintf(stderr,<span class="stringliteral">"\nUnable to compile the packet filter. Check the syntax.\n"</span>);
        <span class="comment">/* Free the device list */</span>
        <span class="keywordflow">return</span>;
    }
    
    <span class="comment">//set the filter</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__wpcapfunc.html#ga21">pcap_setfilter</a>(fp, &amp;fcode)&lt;0)
    {
        fprintf(stderr,<span class="stringliteral">"\nError setting the filter.\n"</span>);
        <span class="comment">/* Free the device list */</span>
        <span class="keywordflow">return</span>;
    }

    <span class="comment">/* Put the interface in statstics mode */</span>
    <a class="code" href="group__wpcapfunc.html#ga48">pcap_setmode</a>(fp, MODE_STAT);

    printf(<span class="stringliteral">"TCP traffic summary:\n"</span>);

    <span class="comment">/* Start the main loop */</span>
    <a class="code" href="group__wpcapfunc.html#ga12">pcap_loop</a>(fp, 0, dispatcher_handler, (PUCHAR)&amp;st_ts);

    <span class="keywordflow">return</span>;
}

<span class="keywordtype">void</span> dispatcher_handler(u_char *state, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data)
{
    <span class="keyword">struct </span>timeval *old_ts = (<span class="keyword">struct </span>timeval *)state;
    u_int delay;
    LARGE_INTEGER Bps,Pps;
    <span class="keyword">struct </span>tm *ltime;
    <span class="keywordtype">char</span> timestr[16];

    <span class="comment">/* Calculate the delay in microseconds from the last sample. */</span>
    <span class="comment">/* This value is obtained from the timestamp that the associated with the sample. */</span>
    delay=(header-&gt;<a class="code" href="structpcap__pkthdr.html#o0">ts</a>.tv_sec - old_ts-&gt;tv_sec) * 1000000 - old_ts-&gt;tv_usec + header-&gt;<a class="code" href="structpcap__pkthdr.html#o0">ts</a>.tv_usec;
    <span class="comment">/* Get the number of Bits per second */</span>
    Bps.QuadPart=(((*(LONGLONG*)(pkt_data + 8)) * 8 * 1000000) / (delay));
    <span class="comment">/*                                            ^      ^</span>
<span class="comment">                                                  |      |</span>
<span class="comment">                                                  |      | </span>
<span class="comment">                                                  |      |</span>
<span class="comment">                         converts bytes in bits --       |</span>
<span class="comment">                                                         |</span>
<span class="comment">                    delay is expressed in microseconds --</span>
<span class="comment">    */</span>

    <span class="comment">/* Get the number of Packets per second */</span>
    Pps.QuadPart=(((*(LONGLONG*)(pkt_data)) * 1000000) / (delay));

    <span class="comment">/* Convert the timestamp to readable format */</span>
    ltime=localtime(&amp;header-&gt;<a class="code" href="structpcap__pkthdr.html#o0">ts</a>.tv_sec);
    strftime( timestr, <span class="keyword">sizeof</span> timestr, <span class="stringliteral">"%H:%M:%S"</span>, ltime);

    <span class="comment">/* Print timestamp*/</span>
    printf(<span class="stringliteral">"%s "</span>, timestr);

    <span class="comment">/* Print the samples */</span>
    printf(<span class="stringliteral">"BPS=%I64u "</span>, Bps.QuadPart);
    printf(<span class="stringliteral">"PPS=%I64u\n"</span>, Pps.QuadPart);

    <span class="comment">//store current timestamp</span>
    old_ts-&gt;tv_sec=header-&gt;<a class="code" href="structpcap__pkthdr.html#o0">ts</a>.tv_sec;
    old_ts-&gt;tv_usec=header-&gt;<a class="code" href="structpcap__pkthdr.html#o0">ts</a>.tv_usec;
}


<span class="keywordtype">void</span> usage()
{
    
    printf(<span class="stringliteral">"\nShows the TCP traffic load, in bits per second and packets per second.\nCopyright (C) 2002 Loris Degioanni.\n"</span>);
    printf(<span class="stringliteral">"\nUsage:\n"</span>);
    printf(<span class="stringliteral">"\t tcptop adapter\n"</span>);
    printf(<span class="stringliteral">"\t You can use \"WinDump -D\" if you don't know the name of your adapters.\n"</span>);

    exit(0);
}
</div></pre><pre><div class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 1999 - 2003</span>
00003 <span class="comment"> * NetGroup, Politecnico di Torino (Italy)</span>
00004 <span class="comment"> * All rights reserved.</span>
00005 <span class="comment"> * </span>
00006 <span class="comment"> * Redistribution and use in source and binary forms, with or without </span>
00007 <span class="comment"> * modification, are permitted provided that the following conditions </span>
00008 <span class="comment"> * are met:</span>
00009 <span class="comment"> * </span>
00010 <span class="comment"> * 1. Redistributions of source code must retain the above copyright </span>
00011 <span class="comment"> * notice, this list of conditions and the following disclaimer.</span>
00012 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright </span>
00013 <span class="comment"> * notice, this list of conditions and the following disclaimer in the </span>
00014 <span class="comment"> * documentation and/or other materials provided with the distribution. </span>
00015 <span class="comment"> * 3. Neither the name of the Politecnico di Torino nor the names of its </span>
00016 <span class="comment"> * contributors may be used to endorse or promote products derived from </span>
00017 <span class="comment"> * this software without specific prior written permission. </span>
00018 <span class="comment"> * </span>
00019 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS </span>
00020 <span class="comment"> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT </span>
00021 <span class="comment"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR </span>
00022 <span class="comment"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT </span>
00023 <span class="comment"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, </span>
00024 <span class="comment"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT </span>
00025 <span class="comment"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, </span>
00026 <span class="comment"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY </span>
00027 <span class="comment"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT </span>
00028 <span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE </span>
00029 <span class="comment"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
00030 <span class="comment"> * </span>
00031 <span class="comment"> */</span>
00032 
00033 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00034 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00035 
00036 <span class="preprocessor">#include &lt;pcap.h&gt;</span>
00037 
00038 <span class="keywordtype">void</span> usage();
00039 
00040 <span class="keywordtype">void</span> dispatcher_handler(u_char *, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *, <span class="keyword">const</span> u_char *);
00041 
00042 
00043 <span class="keywordtype">void</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
00044 {
00045 <a class="code" href="group__wpcap__def.html#ga2">pcap_t</a> *fp;
00046 <span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#ga8">PCAP_ERRBUF_SIZE</a>];
00047 <span class="keyword">struct </span>timeval st_ts;
00048 u_int netmask;
00049 <span class="keyword">struct </span>bpf_program fcode;
00050   
00051     <span class="comment">/* Check the validity of the command line */</span>
00052     <span class="keywordflow">if</span> (argc != 2)
00053     {
00054         usage();
00055         <span class="keywordflow">return</span>;
00056     }
00057         
00058     <span class="comment">/* Open the output adapter */</span>
00059     <span class="keywordflow">if</span> ( (fp= <a class="code" href="remote-ext_8h.html#a15">pcap_open</a>(argv[1], 100, PCAP_OPENFLAG_PROMISCUOUS, 1000, NULL, errbuf) ) == NULL)
00060     {
00061         fprintf(stderr,<span class="stringliteral">"\nUnable to open adapter %s.\n"</span>, errbuf);
00062         <span class="keywordflow">return</span>;
00063     }
00064 
00065     <span class="comment">/* Don't care about netmask, it won't be used for this filter */</span>
00066     netmask=0xffffff; 
00067 
00068     <span class="comment">//compile the filter</span>
00069     <span class="keywordflow">if</span> (<a class="code" href="group__wpcapfunc.html#ga19">pcap_compile</a>(fp, &amp;fcode, <span class="stringliteral">"tcp"</span>, 1, netmask) &lt;0 )
00070     {
00071         fprintf(stderr,<span class="stringliteral">"\nUnable to compile the packet filter. Check the syntax.\n"</span>);
00072         <span class="comment">/* Free the device list */</span>
00073         <span class="keywordflow">return</span>;
00074     }
00075     
00076     <span class="comment">//set the filter</span>
00077     <span class="keywordflow">if</span> (<a class="code" href="group__wpcapfunc.html#ga21">pcap_setfilter</a>(fp, &amp;fcode)&lt;0)
00078     {
00079         fprintf(stderr,<span class="stringliteral">"\nError setting the filter.\n"</span>);
00080         <span class="comment">/* Free the device list */</span>
00081         <span class="keywordflow">return</span>;
00082     }
00083 
00084     <span class="comment">/* Put the interface in statstics mode */</span>
00085     <a class="code" href="group__wpcapfunc.html#ga48">pcap_setmode</a>(fp, MODE_STAT);
00086 
00087     printf(<span class="stringliteral">"TCP traffic summary:\n"</span>);
00088 
00089     <span class="comment">/* Start the main loop */</span>
00090     <a class="code" href="group__wpcapfunc.html#ga12">pcap_loop</a>(fp, 0, dispatcher_handler, (PUCHAR)&amp;st_ts);
00091 
00092     <span class="keywordflow">return</span>;
00093 }
00094 
00095 <span class="keywordtype">void</span> dispatcher_handler(u_char *state, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data)
00096 {
00097     <span class="keyword">struct </span>timeval *old_ts = (<span class="keyword">struct </span>timeval *)state;
00098     u_int delay;
00099     LARGE_INTEGER Bps,Pps;
00100     <span class="keyword">struct </span>tm *ltime;
00101     <span class="keywordtype">char</span> timestr[16];
00102 
00103     <span class="comment">/* Calculate the delay in microseconds from the last sample. */</span>
00104     <span class="comment">/* This value is obtained from the timestamp that the associated with the sample. */</span>
00105     delay=(header-&gt;<a class="code" href="structpcap__pkthdr.html#o0">ts</a>.tv_sec - old_ts-&gt;tv_sec) * 1000000 - old_ts-&gt;tv_usec + header-&gt;<a class="code" href="structpcap__pkthdr.html#o0">ts</a>.tv_usec;
00106     <span class="comment">/* Get the number of Bits per second */</span>
00107     Bps.QuadPart=(((*(LONGLONG*)(pkt_data + 8)) * 8 * 1000000) / (delay));
00108     <span class="comment">/*                                            ^      ^</span>
00109 <span class="comment">                                                  |      |</span>
00110 <span class="comment">                                                  |      | </span>
00111 <span class="comment">                                                  |      |</span>
00112 <span class="comment">                         converts bytes in bits --       |</span>
00113 <span class="comment">                                                         |</span>
00114 <span class="comment">                    delay is expressed in microseconds --</span>
00115 <span class="comment">    */</span>
00116 
00117     <span class="comment">/* Get the number of Packets per second */</span>
00118     Pps.QuadPart=(((*(LONGLONG*)(pkt_data)) * 1000000) / (delay));
00119 
00120     <span class="comment">/* Convert the timestamp to readable format */</span>
00121     ltime=localtime(&amp;header-&gt;<a class="code" href="structpcap__pkthdr.html#o0">ts</a>.tv_sec);
00122     strftime( timestr, <span class="keyword">sizeof</span> timestr, <span class="stringliteral">"%H:%M:%S"</span>, ltime);
00123 
00124     <span class="comment">/* Print timestamp*/</span>
00125     printf(<span class="stringliteral">"%s "</span>, timestr);
00126 
00127     <span class="comment">/* Print the samples */</span>
00128     printf(<span class="stringliteral">"BPS=%I64u "</span>, Bps.QuadPart);
00129     printf(<span class="stringliteral">"PPS=%I64u\n"</span>, Pps.QuadPart);
00130 
00131     <span class="comment">//store current timestamp</span>
00132     old_ts-&gt;tv_sec=header-&gt;<a class="code" href="structpcap__pkthdr.html#o0">ts</a>.tv_sec;
00133     old_ts-&gt;tv_usec=header-&gt;<a class="code" href="structpcap__pkthdr.html#o0">ts</a>.tv_usec;
00134 }
00135 
00136 
00137 <span class="keywordtype">void</span> usage()
00138 {
00139     
00140     printf(<span class="stringliteral">"\nShows the TCP traffic load, in bits per second and packets per second.\nCopyright (C) 2002 Loris Degioanni.\n"</span>);
00141     printf(<span class="stringliteral">"\nUsage:\n"</span>);
00142     printf(<span class="stringliteral">"\t tcptop adapter\n"</span>);
00143     printf(<span class="stringliteral">"\t You can use \"WinDump -D\" if you don't know the name of your adapters.\n"</span>);
00144 
00145     exit(0);
00146 }
</div></pre><p>
Before enabling statistical mode, the user has the option to set a filter that defines the subset of network traffic that will be monitored. See the paragraph on the <a class="el" href="group__language.html">Filtering expression syntax</a> for details. If no filter has been set, all of the traffic will be monitored.<p>
Once<p>
<ul>
<li>the filter is set</li><li><a class="el" href="group__wpcapfunc.html#ga48">pcap_setmode()</a> is called</li><li>callback invocation is enabled with <a class="el" href="group__wpcapfunc.html#ga12">pcap_loop()</a></li></ul>
<p>
the interface descriptor starts to work in statistical mode. Notice the fourth parameter (<em>to_ms</em>) of <a class="el" href="group__wpcapfunc.html#ga58">pcap_open()</a>: it defines the interval among the statistical samples. The callback function receives the samples calculated by the driver every <em>to_ms</em> milliseconds. These samples are encapsulated in the second and third parameters of the callback function, as shown in the following figure:<p>
<div align="center">
<img src="stats_wpcap.gif" alt="stats_wpcap.gif">
</div>
 Two 64-bit counters are provided: the number of packets and the amount of bytes received during the last interval.<p>
In the example, the adapter is opened with a timeout of 1000 ms. This means that dispatcher_handler() is called once per second. At this point a filter that keeps only tcp packets is compiled and set. Then <a class="el" href="group__wpcapfunc.html#ga48">pcap_setmode()</a> and <a class="el" href="group__wpcapfunc.html#ga12">pcap_loop()</a> are called. Note that a struct timeval pointer is passed to <a class="el" href="group__wpcapfunc.html#ga12">pcap_loop()</a> as the <em>user</em> parameter. This structure will be used to store a timestamp in order to calculate the interval between two samples. dispatcher_handler()uses this interval to obtain the bits per second and the packets per second and then prints these values on the screen.<p>
Note finally that this example is by far more efficient than a program that captures the packets in the traditional way and calculates statistics at user-level. Statistical mode requires the minumum amount of data copies and context switches and therefore the CPU is optimized. Moreover, a very small amount of memory is required.<p>
<a class="el" href="group__wpcap__tut8.html">&lt;&lt;&lt; Previous</a> 
<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2005 Politecnico di Torino. Copyright (c) 2005 
CACE technologies. All rights reserved.</p>
