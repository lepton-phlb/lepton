<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>WinPcap: Obtaining advanced information about installed devices</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Obtaining advanced information about installed devices<br>
<small>
[<a class="el" href="group__wpcap__tut.html">WinPcap tutorial: a step by step guide to using WinPcap</a>]</small>
</h1><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
</table>
Lesson 1 (<a class="el" href="group__wpcap__tut1.html">Obtaining the device list</a>) demonstrated how to get basic information (i.e. device name and description) about available adapters. Actually, WinPcap provides also other advanced information. In particular, every <a class="el" href="structpcap__if.html">pcap_if</a> structure returned by <a class="el" href="group__wpcapfunc.html#ga55">pcap_findalldevs_ex()</a> contains also a list of <a class="el" href="structpcap__addr.html">pcap_addr</a> structures, with:<ul>
<li>a list of addresses for that interface.</li><li>a list of netmasks (each of which corresponds to an entry in the addresses list).</li><li>a list of broadcast addresses (each of which corresponds to an entry in the addresses list).</li><li>a list of destination addresses (each of which corresponds to an entry in the addresses list).</li></ul>
<p>
Additionally, <a class="el" href="group__wpcapfunc.html#ga55">pcap_findalldevs_ex()</a> can also return remote adapters and a list of pcap files that are located in a given local folder.<p>
The following sample provides an ifprint() function that prints the complete contents of a <a class="el" href="structpcap__if.html">pcap_if</a> structure. It is invoked by the program for every entry returned by <a class="el" href="group__wpcapfunc.html#ga55">pcap_findalldevs_ex()</a>.<p>
<pre><div class="fragment"><span class="comment">/*</span>
<span class="comment"> * Copyright (c) 1999 - 2003</span>
<span class="comment"> * NetGroup, Politecnico di Torino (Italy)</span>
<span class="comment"> * All rights reserved.</span>
<span class="comment"> * </span>
<span class="comment"> * Redistribution and use in source and binary forms, with or without </span>
<span class="comment"> * modification, are permitted provided that the following conditions </span>
<span class="comment"> * are met:</span>
<span class="comment"> * </span>
<span class="comment"> * 1. Redistributions of source code must retain the above copyright </span>
<span class="comment"> * notice, this list of conditions and the following disclaimer.</span>
<span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright </span>
<span class="comment"> * notice, this list of conditions and the following disclaimer in the </span>
<span class="comment"> * documentation and/or other materials provided with the distribution. </span>
<span class="comment"> * 3. Neither the name of the Politecnico di Torino nor the names of its </span>
<span class="comment"> * contributors may be used to endorse or promote products derived from </span>
<span class="comment"> * this software without specific prior written permission. </span>
<span class="comment"> * </span>
<span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS </span>
<span class="comment"> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT </span>
<span class="comment"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR </span>
<span class="comment"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT </span>
<span class="comment"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, </span>
<span class="comment"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT </span>
<span class="comment"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, </span>
<span class="comment"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY </span>
<span class="comment"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT </span>
<span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE </span>
<span class="comment"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="comment"> * </span>
<span class="comment"> */</span>


<span class="preprocessor">#include "pcap.h"</span>

<span class="preprocessor">#ifndef WIN32</span>
<span class="preprocessor"></span><span class="preprocessor">    #include &lt;sys/socket.h&gt;</span>
<span class="preprocessor">    #include &lt;netinet/in.h&gt;</span>
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">    #include &lt;winsock.h&gt;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>

<span class="comment">// Function prototypes</span>
<span class="keywordtype">void</span> ifprint(<a class="code" href="structpcap__if.html">pcap_if_t</a> *d);
<span class="keywordtype">char</span> *iptos(u_long in);
<span class="keywordtype">char</span>* ip6tos(<span class="keyword">struct</span> sockaddr *sockaddr, <span class="keywordtype">char</span> *address, <span class="keywordtype">int</span> addrlen);


<span class="keywordtype">int</span> main()
{
  <a class="code" href="structpcap__if.html">pcap_if_t</a> *alldevs;
  <a class="code" href="structpcap__if.html">pcap_if_t</a> *d;
  <span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#ga8">PCAP_ERRBUF_SIZE</a>+1];
  <span class="keywordtype">char</span> source[<a class="code" href="group__wpcap__def.html#ga8">PCAP_ERRBUF_SIZE</a>+1];

  printf(<span class="stringliteral">"Enter the device you want to list:\n"</span>
            <span class="stringliteral">"rpcap://              ==&gt; lists interfaces in the local machine\n"</span>
            <span class="stringliteral">"rpcap://hostname:port ==&gt; lists interfaces in a remote machine\n"</span>
            <span class="stringliteral">"                          (rpcapd daemon must be up and running\n"</span>
            <span class="stringliteral">"                           and it must accept 'null' authentication)\n"</span>
            <span class="stringliteral">"file://foldername     ==&gt; lists all pcap files in the give folder\n\n"</span>
            <span class="stringliteral">"Enter your choice: "</span>);

  fgets(source, PCAP_ERRBUF_SIZE, stdin);
  source[<a class="code" href="group__wpcap__def.html#ga8">PCAP_ERRBUF_SIZE</a>] = <span class="charliteral">'\0'</span>;

  <span class="comment">/* Retrieve the interfaces list */</span>
  <span class="keywordflow">if</span> (<a class="code" href="group__wpcapfunc.html#ga55">pcap_findalldevs_ex</a>(source, NULL, &amp;alldevs, errbuf) == -1)
  {
    fprintf(stderr,<span class="stringliteral">"Error in pcap_findalldevs: %s\n"</span>,errbuf);
    exit(1);
  }

  <span class="comment">/* Scan the list printing every entry */</span>
  <span class="keywordflow">for</span>(d=alldevs;d;d=d-&gt;<a class="code" href="structpcap__if.html#o0">next</a>)
  {
    ifprint(d);
  }

  <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);

  <span class="keywordflow">return</span> 1;
}



<span class="comment">/* Print all the available information on the given interface */</span>
<span class="keywordtype">void</span> ifprint(<a class="code" href="structpcap__if.html">pcap_if_t</a> *d)
{
  <a class="code" href="structpcap__addr.html">pcap_addr_t</a> *a;
  <span class="keywordtype">char</span> ip6str[128];

  <span class="comment">/* Name */</span>
  printf(<span class="stringliteral">"%s\n"</span>,d-&gt;<a class="code" href="structpcap__if.html#o1">name</a>);

  <span class="comment">/* Description */</span>
  <span class="keywordflow">if</span> (d-&gt;<a class="code" href="structpcap__if.html#o2">description</a>)
    printf(<span class="stringliteral">"\tDescription: %s\n"</span>,d-&gt;<a class="code" href="structpcap__if.html#o2">description</a>);

  <span class="comment">/* Loopback Address*/</span>
  printf(<span class="stringliteral">"\tLoopback: %s\n"</span>,(d-&gt;<a class="code" href="structpcap__if.html#o4">flags</a> &amp; PCAP_IF_LOOPBACK)?<span class="stringliteral">"yes"</span>:<span class="stringliteral">"no"</span>);

  <span class="comment">/* IP addresses */</span>
  <span class="keywordflow">for</span>(a=d-&gt;<a class="code" href="structpcap__if.html#o3">addresses</a>;a;a=a-&gt;<a class="code" href="structpcap__addr.html#o0">next</a>) {
    printf(<span class="stringliteral">"\tAddress Family: #%d\n"</span>,a-&gt;<a class="code" href="structpcap__addr.html#o1">addr</a>-&gt;sa_family);
  
    <span class="keywordflow">switch</span>(a-&gt;<a class="code" href="structpcap__addr.html#o1">addr</a>-&gt;sa_family)
    {
      <span class="keywordflow">case</span> AF_INET:
        printf(<span class="stringliteral">"\tAddress Family Name: AF_INET\n"</span>);
        <span class="keywordflow">if</span> (a-&gt;<a class="code" href="structpcap__addr.html#o1">addr</a>)
          printf(<span class="stringliteral">"\tAddress: %s\n"</span>,iptos(((<span class="keyword">struct</span> sockaddr_in *)a-&gt;<a class="code" href="structpcap__addr.html#o1">addr</a>)-&gt;sin_addr.s_addr));
        <span class="keywordflow">if</span> (a-&gt;<a class="code" href="structpcap__addr.html#o2">netmask</a>)
          printf(<span class="stringliteral">"\tNetmask: %s\n"</span>,iptos(((<span class="keyword">struct</span> sockaddr_in *)a-&gt;<a class="code" href="structpcap__addr.html#o2">netmask</a>)-&gt;sin_addr.s_addr));
        <span class="keywordflow">if</span> (a-&gt;<a class="code" href="structpcap__addr.html#o3">broadaddr</a>)
          printf(<span class="stringliteral">"\tBroadcast Address: %s\n"</span>,iptos(((<span class="keyword">struct</span> sockaddr_in *)a-&gt;<a class="code" href="structpcap__addr.html#o3">broadaddr</a>)-&gt;sin_addr.s_addr));
        <span class="keywordflow">if</span> (a-&gt;<a class="code" href="structpcap__addr.html#o4">dstaddr</a>)
          printf(<span class="stringliteral">"\tDestination Address: %s\n"</span>,iptos(((<span class="keyword">struct</span> sockaddr_in *)a-&gt;<a class="code" href="structpcap__addr.html#o4">dstaddr</a>)-&gt;sin_addr.s_addr));
        <span class="keywordflow">break</span>;

      <span class="keywordflow">case</span> AF_INET6:
        printf(<span class="stringliteral">"\tAddress Family Name: AF_INET6\n"</span>);
        <span class="keywordflow">if</span> (a-&gt;<a class="code" href="structpcap__addr.html#o1">addr</a>)
          printf(<span class="stringliteral">"\tAddress: %s\n"</span>, ip6tos(a-&gt;<a class="code" href="structpcap__addr.html#o1">addr</a>, ip6str, <span class="keyword">sizeof</span>(ip6str)));
       <span class="keywordflow">break</span>;

      <span class="keywordflow">default</span>:
        printf(<span class="stringliteral">"\tAddress Family Name: Unknown\n"</span>);
        <span class="keywordflow">break</span>;
    }
  }
  printf(<span class="stringliteral">"\n"</span>);
}



<span class="comment">/* From tcptraceroute, convert a numeric IP address to a string */</span>
<span class="preprocessor">#define IPTOSBUFFERS    12</span>
<span class="preprocessor"></span><span class="keywordtype">char</span> *iptos(u_long in)
{
    <span class="keyword">static</span> <span class="keywordtype">char</span> output[IPTOSBUFFERS][3*4+3+1];
    <span class="keyword">static</span> <span class="keywordtype">short</span> which;
    u_char *p;

    p = (u_char *)&amp;in;
    which = (which + 1 == IPTOSBUFFERS ? 0 : which + 1);
    sprintf(output[which], <span class="stringliteral">"%d.%d.%d.%d"</span>, p[0], p[1], p[2], p[3]);
    <span class="keywordflow">return</span> output[which];
}

<span class="keywordtype">char</span>* ip6tos(<span class="keyword">struct</span> sockaddr *sockaddr, <span class="keywordtype">char</span> *address, <span class="keywordtype">int</span> addrlen)
{
    socklen_t sockaddrlen;

<span class="preprocessor">    #ifdef WIN32</span>
<span class="preprocessor"></span>    sockaddrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_in6);
<span class="preprocessor">    #else</span>
<span class="preprocessor"></span>    sockaddrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_storage);
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>

    <span class="keywordflow">if</span>(getnameinfo(sockaddr, 
        sockaddrlen, 
        address, 
        addrlen, 
        NULL, 
        0, 
        NI_NUMERICHOST) != 0) address = NULL;

    <span class="keywordflow">return</span> address;
}


</div></pre><pre><div class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (c) 1999 - 2003</span>
00003 <span class="comment"> * NetGroup, Politecnico di Torino (Italy)</span>
00004 <span class="comment"> * All rights reserved.</span>
00005 <span class="comment"> * </span>
00006 <span class="comment"> * Redistribution and use in source and binary forms, with or without </span>
00007 <span class="comment"> * modification, are permitted provided that the following conditions </span>
00008 <span class="comment"> * are met:</span>
00009 <span class="comment"> * </span>
00010 <span class="comment"> * 1. Redistributions of source code must retain the above copyright </span>
00011 <span class="comment"> * notice, this list of conditions and the following disclaimer.</span>
00012 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright </span>
00013 <span class="comment"> * notice, this list of conditions and the following disclaimer in the </span>
00014 <span class="comment"> * documentation and/or other materials provided with the distribution. </span>
00015 <span class="comment"> * 3. Neither the name of the Politecnico di Torino nor the names of its </span>
00016 <span class="comment"> * contributors may be used to endorse or promote products derived from </span>
00017 <span class="comment"> * this software without specific prior written permission. </span>
00018 <span class="comment"> * </span>
00019 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS </span>
00020 <span class="comment"> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT </span>
00021 <span class="comment"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR </span>
00022 <span class="comment"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT </span>
00023 <span class="comment"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, </span>
00024 <span class="comment"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT </span>
00025 <span class="comment"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, </span>
00026 <span class="comment"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY </span>
00027 <span class="comment"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT </span>
00028 <span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE </span>
00029 <span class="comment"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
00030 <span class="comment"> * </span>
00031 <span class="comment"> */</span>
00032 
00033 
00034 <span class="preprocessor">#include "pcap.h"</span>
00035 
00036 <span class="preprocessor">#ifndef WIN32</span>
00037 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;sys/socket.h&gt;</span>
00038 <span class="preprocessor">    #include &lt;netinet/in.h&gt;</span>
00039 <span class="preprocessor">#else</span>
00040 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;winsock.h&gt;</span>
00041 <span class="preprocessor">#endif</span>
00042 <span class="preprocessor"></span>
00043 
00044 <span class="comment">// Function prototypes</span>
00045 <span class="keywordtype">void</span> ifprint(<a class="code" href="structpcap__if.html">pcap_if_t</a> *d);
00046 <span class="keywordtype">char</span> *iptos(u_long in);
00047 <span class="keywordtype">char</span>* ip6tos(<span class="keyword">struct</span> sockaddr *sockaddr, <span class="keywordtype">char</span> *address, <span class="keywordtype">int</span> addrlen);
00048 
00049 
00050 <span class="keywordtype">int</span> main()
00051 {
00052   <a class="code" href="structpcap__if.html">pcap_if_t</a> *alldevs;
00053   <a class="code" href="structpcap__if.html">pcap_if_t</a> *d;
00054   <span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#ga8">PCAP_ERRBUF_SIZE</a>+1];
00055   <span class="keywordtype">char</span> source[<a class="code" href="group__wpcap__def.html#ga8">PCAP_ERRBUF_SIZE</a>+1];
00056 
00057   printf(<span class="stringliteral">"Enter the device you want to list:\n"</span>
00058             <span class="stringliteral">"rpcap://              ==&gt; lists interfaces in the local machine\n"</span>
00059             <span class="stringliteral">"rpcap://hostname:port ==&gt; lists interfaces in a remote machine\n"</span>
00060             <span class="stringliteral">"                          (rpcapd daemon must be up and running\n"</span>
00061             <span class="stringliteral">"                           and it must accept 'null' authentication)\n"</span>
00062             <span class="stringliteral">"file://foldername     ==&gt; lists all pcap files in the give folder\n\n"</span>
00063             <span class="stringliteral">"Enter your choice: "</span>);
00064 
00065   fgets(source, PCAP_ERRBUF_SIZE, stdin);
00066   source[<a class="code" href="group__wpcap__def.html#ga8">PCAP_ERRBUF_SIZE</a>] = <span class="charliteral">'\0'</span>;
00067 
00068   <span class="comment">/* Retrieve the interfaces list */</span>
00069   <span class="keywordflow">if</span> (<a class="code" href="remote-ext_8h.html#a18">pcap_findalldevs_ex</a>(source, NULL, &amp;alldevs, errbuf) == -1)
00070   {
00071     fprintf(stderr,<span class="stringliteral">"Error in pcap_findalldevs: %s\n"</span>,errbuf);
00072     exit(1);
00073   }
00074 
00075   <span class="comment">/* Scan the list printing every entry */</span>
00076   <span class="keywordflow">for</span>(d=alldevs;d;d=d-&gt;<a class="code" href="structpcap__if.html#o0">next</a>)
00077   {
00078     ifprint(d);
00079   }
00080 
00081   <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);
00082 
00083   <span class="keywordflow">return</span> 1;
00084 }
00085 
00086 
00087 
00088 <span class="comment">/* Print all the available information on the given interface */</span>
00089 <span class="keywordtype">void</span> ifprint(<a class="code" href="structpcap__if.html">pcap_if_t</a> *d)
00090 {
00091   <a class="code" href="structpcap__addr.html">pcap_addr_t</a> *a;
00092   <span class="keywordtype">char</span> ip6str[128];
00093 
00094   <span class="comment">/* Name */</span>
00095   printf(<span class="stringliteral">"%s\n"</span>,d-&gt;<a class="code" href="structpcap__if.html#o1">name</a>);
00096 
00097   <span class="comment">/* Description */</span>
00098   <span class="keywordflow">if</span> (d-&gt;<a class="code" href="structpcap__if.html#o2">description</a>)
00099     printf(<span class="stringliteral">"\tDescription: %s\n"</span>,d-&gt;<a class="code" href="structpcap__if.html#o2">description</a>);
00100 
00101   <span class="comment">/* Loopback Address*/</span>
00102   printf(<span class="stringliteral">"\tLoopback: %s\n"</span>,(d-&gt;<a class="code" href="structpcap__if.html#o4">flags</a> &amp; PCAP_IF_LOOPBACK)?<span class="stringliteral">"yes"</span>:<span class="stringliteral">"no"</span>);
00103 
00104   <span class="comment">/* IP addresses */</span>
00105   <span class="keywordflow">for</span>(a=d-&gt;<a class="code" href="structpcap__if.html#o3">addresses</a>;a;a=a-&gt;<a class="code" href="structpcap__addr.html#o0">next</a>) {
00106     printf(<span class="stringliteral">"\tAddress Family: #%d\n"</span>,a-&gt;<a class="code" href="structpcap__addr.html#o1">addr</a>-&gt;sa_family);
00107   
00108     <span class="keywordflow">switch</span>(a-&gt;<a class="code" href="structpcap__addr.html#o1">addr</a>-&gt;sa_family)
00109     {
00110       <span class="keywordflow">case</span> AF_INET:
00111         printf(<span class="stringliteral">"\tAddress Family Name: AF_INET\n"</span>);
00112         <span class="keywordflow">if</span> (a-&gt;<a class="code" href="structpcap__addr.html#o1">addr</a>)
00113           printf(<span class="stringliteral">"\tAddress: %s\n"</span>,iptos(((<span class="keyword">struct</span> sockaddr_in *)a-&gt;<a class="code" href="structpcap__addr.html#o1">addr</a>)-&gt;sin_addr.s_addr));
00114         <span class="keywordflow">if</span> (a-&gt;<a class="code" href="structpcap__addr.html#o2">netmask</a>)
00115           printf(<span class="stringliteral">"\tNetmask: %s\n"</span>,iptos(((<span class="keyword">struct</span> sockaddr_in *)a-&gt;<a class="code" href="structpcap__addr.html#o2">netmask</a>)-&gt;sin_addr.s_addr));
00116         <span class="keywordflow">if</span> (a-&gt;<a class="code" href="structpcap__addr.html#o3">broadaddr</a>)
00117           printf(<span class="stringliteral">"\tBroadcast Address: %s\n"</span>,iptos(((<span class="keyword">struct</span> sockaddr_in *)a-&gt;<a class="code" href="structpcap__addr.html#o3">broadaddr</a>)-&gt;sin_addr.s_addr));
00118         <span class="keywordflow">if</span> (a-&gt;<a class="code" href="structpcap__addr.html#o4">dstaddr</a>)
00119           printf(<span class="stringliteral">"\tDestination Address: %s\n"</span>,iptos(((<span class="keyword">struct</span> sockaddr_in *)a-&gt;<a class="code" href="structpcap__addr.html#o4">dstaddr</a>)-&gt;sin_addr.s_addr));
00120         <span class="keywordflow">break</span>;
00121 
00122       <span class="keywordflow">case</span> AF_INET6:
00123         printf(<span class="stringliteral">"\tAddress Family Name: AF_INET6\n"</span>);
00124         <span class="keywordflow">if</span> (a-&gt;<a class="code" href="structpcap__addr.html#o1">addr</a>)
00125           printf(<span class="stringliteral">"\tAddress: %s\n"</span>, ip6tos(a-&gt;<a class="code" href="structpcap__addr.html#o1">addr</a>, ip6str, <span class="keyword">sizeof</span>(ip6str)));
00126        <span class="keywordflow">break</span>;
00127 
00128       <span class="keywordflow">default</span>:
00129         printf(<span class="stringliteral">"\tAddress Family Name: Unknown\n"</span>);
00130         <span class="keywordflow">break</span>;
00131     }
00132   }
00133   printf(<span class="stringliteral">"\n"</span>);
00134 }
00135 
00136 
00137 
00138 <span class="comment">/* From tcptraceroute, convert a numeric IP address to a string */</span>
00139 <span class="preprocessor">#define IPTOSBUFFERS    12</span>
00140 <span class="preprocessor"></span><span class="keywordtype">char</span> *iptos(u_long in)
00141 {
00142     <span class="keyword">static</span> <span class="keywordtype">char</span> output[IPTOSBUFFERS][3*4+3+1];
00143     <span class="keyword">static</span> <span class="keywordtype">short</span> which;
00144     u_char *p;
00145 
00146     p = (u_char *)&amp;in;
00147     which = (which + 1 == IPTOSBUFFERS ? 0 : which + 1);
00148     sprintf(output[which], <span class="stringliteral">"%d.%d.%d.%d"</span>, p[0], p[1], p[2], p[3]);
00149     <span class="keywordflow">return</span> output[which];
00150 }
00151 
00152 <span class="keywordtype">char</span>* ip6tos(<span class="keyword">struct</span> sockaddr *sockaddr, <span class="keywordtype">char</span> *address, <span class="keywordtype">int</span> addrlen)
00153 {
00154     socklen_t sockaddrlen;
00155 
00156 <span class="preprocessor">    #ifdef WIN32</span>
00157 <span class="preprocessor"></span>    sockaddrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_in6);
00158 <span class="preprocessor">    #else</span>
00159 <span class="preprocessor"></span>    sockaddrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_storage);
00160 <span class="preprocessor">    #endif</span>
00161 <span class="preprocessor"></span>
00162 
00163     <span class="keywordflow">if</span>(getnameinfo(sockaddr, 
00164         sockaddrlen, 
00165         address, 
00166         addrlen, 
00167         NULL, 
00168         0, 
00169         NI_NUMERICHOST) != 0) address = NULL;
00170 
00171     <span class="keywordflow">return</span> address;
00172 }
00173 
00174 
</div></pre><p>
<a class="el" href="group__wpcap__tut1.html">&lt;&lt;&lt; Previous</a> <a class="el" href="group__wpcap__tut3.html">Next &gt;&gt;&gt;</a> 
<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2005 Politecnico di Torino. Copyright (c) 2005 
CACE technologies. All rights reserved.</p>
