<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>WinPcap: Opening an adapter and capturing the packets</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Opening an adapter and capturing the packets<br>
<small>
[<a class="el" href="group__wpcap__tut.html">WinPcap tutorial: a step by step guide to using WinPcap</a>]</small>
</h1><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
</table>
Now that we've seen how to obtain an adapter to play with, let's start the real job, opening an adapter and capturing some traffic. In this lesson we'll write a program that prints some information about each packet flowing through the adapter.<p>
The function that opens a capture device is <a class="el" href="group__wpcapfunc.html#ga58">pcap_open()</a>. The parameters, <em>snaplen</em>, <em>flags</em> and <em>to_ms</em> deserve some explanation.<p>
<em>snaplen</em> specifies the portion of the packet to capture. On some OSes (like xBSD and Win32), the packet driver can be configured to capture only the initial part of any packet: this decreases the amount of data to copy to the application and therefore improves the efficiency of the capture. In this case we use the value 65536 which is higher than the greatest MTU that we could encounter. In this manner we ensure that the application will always receive the whole packet.<p>
<em>flags:</em> the most important flag is the one that indicates if the adapter will be put in promiscuous mode. In normal operation, an adapter only captures packets from the network that are destined to it; the packets exchanged by other hosts are therefore ignored. Instead, when the adapter is in promiscuous mode it captures all packets whether they are destined to it or not. This means that on shared media (like non-switched Ethernet), WinPcap will be able to capture the packets of other hosts. Promiscuous mode is the default for most capture applications, so we enable it in the following example.<p>
<em>to_ms</em> specifies the read timeout, in milliseconds. A read on the adapter (for example, with <a class="el" href="group__wpcapfunc.html#ga11">pcap_dispatch()</a> or <a class="el" href="group__wpcapfunc.html#ga14">pcap_next_ex()</a>) will always return after <em>to_ms</em> milliseconds, even if no packets are available from the network. <em>to_ms</em> also defines the interval between statistical reports if the adapter is in statistical mode (see the lesson "\ref wpcap_tut9" for information about statistical mode). Setting <em>to_ms</em> to 0 means no timeout, a read on the adapter never returns if no packets arrive. A -1 timeout on the other side causes a read on the adapter to always return immediately.<p>
<pre><div class="fragment"><span class="preprocessor">#include "pcap.h"</span>

<span class="comment">/* prototype of the packet handler */</span>
<span class="keywordtype">void</span> packet_handler(u_char *param, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data);

main()
{
<a class="code" href="structpcap__if.html">pcap_if_t</a> *alldevs;
<a class="code" href="structpcap__if.html">pcap_if_t</a> *d;
<span class="keywordtype">int</span> inum;
<span class="keywordtype">int</span> i=0;
<a class="code" href="group__wpcap__def.html#ga2">pcap_t</a> *adhandle;
<span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#ga8">PCAP_ERRBUF_SIZE</a>];
    
    <span class="comment">/* Retrieve the device list on the local machine */</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__wpcapfunc.html#ga55">pcap_findalldevs_ex</a>(PCAP_SRC_IF_STRING, NULL, &amp;alldevs, errbuf) == -1)
    {
        fprintf(stderr,<span class="stringliteral">"Error in pcap_findalldevs: %s\n"</span>, errbuf);
        exit(1);
    }
    
    <span class="comment">/* Print the list */</span>
    <span class="keywordflow">for</span>(d=alldevs; d; d=d-&gt;<a class="code" href="structpcap__if.html#o0">next</a>)
    {
        printf(<span class="stringliteral">"%d. %s"</span>, ++i, d-&gt;<a class="code" href="structpcap__if.html#o1">name</a>);
        <span class="keywordflow">if</span> (d-&gt;<a class="code" href="structpcap__if.html#o2">description</a>)
            printf(<span class="stringliteral">" (%s)\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#o2">description</a>);
        <span class="keywordflow">else</span>
            printf(<span class="stringliteral">" (No description available)\n"</span>);
    }
    
    <span class="keywordflow">if</span>(i==0)
    {
        printf(<span class="stringliteral">"\nNo interfaces found! Make sure WinPcap is installed.\n"</span>);
        <span class="keywordflow">return</span> -1;
    }
    
    printf(<span class="stringliteral">"Enter the interface number (1-%d):"</span>,i);
    scanf(<span class="stringliteral">"%d"</span>, &amp;inum);
    
    <span class="keywordflow">if</span>(inum &lt; 1 || inum &gt; i)
    {
        printf(<span class="stringliteral">"\nInterface number out of range.\n"</span>);
        <span class="comment">/* Free the device list */</span>
        <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="comment">/* Jump to the selected adapter */</span>
    <span class="keywordflow">for</span>(d=alldevs, i=0; i&lt; inum-1 ;d=d-&gt;<a class="code" href="structpcap__if.html#o0">next</a>, i++);
    
    <span class="comment">/* Open the device */</span>
    <span class="keywordflow">if</span> ( (adhandle= <a class="code" href="group__wpcapfunc.html#ga58">pcap_open</a>(d-&gt;<a class="code" href="structpcap__if.html#o1">name</a>,          <span class="comment">// name of the device</span>
                              65536,            <span class="comment">// portion of the packet to capture</span>
                                                <span class="comment">// 65536 guarantees that the whole packet will be captured on all the link layers</span>
                              PCAP_OPENFLAG_PROMISCUOUS,    <span class="comment">// promiscuous mode</span>
                              1000,             <span class="comment">// read timeout</span>
                              NULL,             <span class="comment">// authentication on the remote machine</span>
                              errbuf            <span class="comment">// error buffer</span>
                              ) ) == NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nUnable to open the adapter. %s is not supported by WinPcap\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#o1">name</a>);
        <span class="comment">/* Free the device list */</span>
        <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);
        <span class="keywordflow">return</span> -1;
    }
    
    printf(<span class="stringliteral">"\nlistening on %s...\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#o2">description</a>);
    
    <span class="comment">/* At this point, we don't need any more the device list. Free it */</span>
    <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);
    
    <span class="comment">/* start the capture */</span>
    <a class="code" href="group__wpcapfunc.html#ga12">pcap_loop</a>(adhandle, 0, packet_handler, NULL);
    
    <span class="keywordflow">return</span> 0;
}


<span class="comment">/* Callback function invoked by libpcap for every incoming packet */</span>
<span class="keywordtype">void</span> packet_handler(u_char *param, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data)
{
    <span class="keyword">struct </span>tm *ltime;
    <span class="keywordtype">char</span> timestr[16];
    
    <span class="comment">/* convert the timestamp to readable format */</span>
    ltime=localtime(&amp;header-&gt;<a class="code" href="structpcap__pkthdr.html#o0">ts</a>.tv_sec);
    strftime( timestr, <span class="keyword">sizeof</span> timestr, <span class="stringliteral">"%H:%M:%S"</span>, ltime);
    
    printf(<span class="stringliteral">"%s,%.6d len:%d\n"</span>, timestr, header-&gt;<a class="code" href="structpcap__pkthdr.html#o0">ts</a>.tv_usec, header-&gt;<a class="code" href="structpcap__pkthdr.html#o2">len</a>);
    
}
</div></pre><pre><div class="fragment">00001 <span class="preprocessor">#include "pcap.h"</span>
00002 
00003 <span class="comment">/* prototype of the packet handler */</span>
00004 <span class="keywordtype">void</span> packet_handler(u_char *param, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data);
00005 
00006 main()
00007 {
00008 <a class="code" href="structpcap__if.html">pcap_if_t</a> *alldevs;
00009 <a class="code" href="structpcap__if.html">pcap_if_t</a> *d;
00010 <span class="keywordtype">int</span> inum;
00011 <span class="keywordtype">int</span> i=0;
00012 <a class="code" href="group__wpcap__def.html#ga2">pcap_t</a> *adhandle;
00013 <span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#ga8">PCAP_ERRBUF_SIZE</a>];
00014     
00015     <span class="comment">/* Retrieve the device list on the local machine */</span>
00016     <span class="keywordflow">if</span> (<a class="code" href="remote-ext_8h.html#a18">pcap_findalldevs_ex</a>(PCAP_SRC_IF_STRING, NULL, &amp;alldevs, errbuf) == -1)
00017     {
00018         fprintf(stderr,<span class="stringliteral">"Error in pcap_findalldevs: %s\n"</span>, errbuf);
00019         exit(1);
00020     }
00021     
00022     <span class="comment">/* Print the list */</span>
00023     <span class="keywordflow">for</span>(d=alldevs; d; d=d-&gt;<a class="code" href="structpcap__if.html#o0">next</a>)
00024     {
00025         printf(<span class="stringliteral">"%d. %s"</span>, ++i, d-&gt;<a class="code" href="structpcap__if.html#o1">name</a>);
00026         <span class="keywordflow">if</span> (d-&gt;<a class="code" href="structpcap__if.html#o2">description</a>)
00027             printf(<span class="stringliteral">" (%s)\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#o2">description</a>);
00028         <span class="keywordflow">else</span>
00029             printf(<span class="stringliteral">" (No description available)\n"</span>);
00030     }
00031     
00032     <span class="keywordflow">if</span>(i==0)
00033     {
00034         printf(<span class="stringliteral">"\nNo interfaces found! Make sure WinPcap is installed.\n"</span>);
00035         <span class="keywordflow">return</span> -1;
00036     }
00037     
00038     printf(<span class="stringliteral">"Enter the interface number (1-%d):"</span>,i);
00039     scanf(<span class="stringliteral">"%d"</span>, &amp;inum);
00040     
00041     <span class="keywordflow">if</span>(inum &lt; 1 || inum &gt; i)
00042     {
00043         printf(<span class="stringliteral">"\nInterface number out of range.\n"</span>);
00044         <span class="comment">/* Free the device list */</span>
00045         <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);
00046         <span class="keywordflow">return</span> -1;
00047     }
00048     
00049     <span class="comment">/* Jump to the selected adapter */</span>
00050     <span class="keywordflow">for</span>(d=alldevs, i=0; i&lt; inum-1 ;d=d-&gt;<a class="code" href="structpcap__if.html#o0">next</a>, i++);
00051     
00052     <span class="comment">/* Open the device */</span>
00053     <span class="keywordflow">if</span> ( (adhandle= <a class="code" href="remote-ext_8h.html#a15">pcap_open</a>(d-&gt;<a class="code" href="structpcap__if.html#o1">name</a>,          <span class="comment">// name of the device</span>
00054                               65536,            <span class="comment">// portion of the packet to capture</span>
00055                                                 <span class="comment">// 65536 guarantees that the whole packet will be captured on all the link layers</span>
00056                               PCAP_OPENFLAG_PROMISCUOUS,    <span class="comment">// promiscuous mode</span>
00057                               1000,             <span class="comment">// read timeout</span>
00058                               NULL,             <span class="comment">// authentication on the remote machine</span>
00059                               errbuf            <span class="comment">// error buffer</span>
00060                               ) ) == NULL)
00061     {
00062         fprintf(stderr,<span class="stringliteral">"\nUnable to open the adapter. %s is not supported by WinPcap\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#o1">name</a>);
00063         <span class="comment">/* Free the device list */</span>
00064         <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);
00065         <span class="keywordflow">return</span> -1;
00066     }
00067     
00068     printf(<span class="stringliteral">"\nlistening on %s...\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#o2">description</a>);
00069     
00070     <span class="comment">/* At this point, we don't need any more the device list. Free it */</span>
00071     <a class="code" href="group__wpcapfunc.html#ga8">pcap_freealldevs</a>(alldevs);
00072     
00073     <span class="comment">/* start the capture */</span>
00074     <a class="code" href="group__wpcapfunc.html#ga12">pcap_loop</a>(adhandle, 0, packet_handler, NULL);
00075     
00076     <span class="keywordflow">return</span> 0;
00077 }
00078 
00079 
00080 <span class="comment">/* Callback function invoked by libpcap for every incoming packet */</span>
00081 <span class="keywordtype">void</span> packet_handler(u_char *param, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data)
00082 {
00083     <span class="keyword">struct </span>tm *ltime;
00084     <span class="keywordtype">char</span> timestr[16];
00085     
00086     <span class="comment">/* convert the timestamp to readable format */</span>
00087     ltime=localtime(&amp;header-&gt;<a class="code" href="structpcap__pkthdr.html#o0">ts</a>.tv_sec);
00088     strftime( timestr, <span class="keyword">sizeof</span> timestr, <span class="stringliteral">"%H:%M:%S"</span>, ltime);
00089     
00090     printf(<span class="stringliteral">"%s,%.6d len:%d\n"</span>, timestr, header-&gt;<a class="code" href="structpcap__pkthdr.html#o0">ts</a>.tv_usec, header-&gt;<a class="code" href="structpcap__pkthdr.html#o2">len</a>);
00091     
00092 }
</div></pre><p>
Once the adapter is opened, the capture can be started with <a class="el" href="group__wpcapfunc.html#ga11">pcap_dispatch()</a> or <a class="el" href="group__wpcapfunc.html#ga12">pcap_loop()</a>. These two functions are very similar, the difference is that pcap_ dispatch() returns (although not guaranteed) when the timeout expires while <a class="el" href="group__wpcapfunc.html#ga12">pcap_loop()</a> doesn't return until <em>cnt</em> packets have been captured, so it can block for an arbitrary period on an under-utilized network. <a class="el" href="group__wpcapfunc.html#ga12">pcap_loop()</a> is enough for the purpose of this sample, while <a class="el" href="group__wpcapfunc.html#ga11">pcap_dispatch()</a> is normally used in a more complex program.<p>
Both of these functions have a <em>callback</em> parameter, <em>packet_handler</em>, pointing to a function that will receive the packets. This function is invoked by libpcap for every new packet coming from the network and receives a generic status (corresponding to the <em>user</em> parameter of <a class="el" href="group__wpcapfunc.html#ga12">pcap_loop()</a> and <a class="el" href="group__wpcapfunc.html#ga11">pcap_dispatch()</a>), a header with some information on the packet like the timestamp and the length and the actual data of the packet including all the protocol headers. Note that the frame CRC is normally not present, because it is removed by the network adapter after frame validation. Note also that most adapters discard packets with wrong CRCs, therefore WinPcap is normally not able to capture them.<p>
The above example extracts the timestamp and the length of every packet from the <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> header and prints them on the screen.<p>
Please note that there may be a drawback using <a class="el" href="group__wpcapfunc.html#ga12">pcap_loop()</a> mainly related to the fact that the handler is called by the packet capture driver; therefore the user application does not have direct control over it. Another approach (and to have more readable programs) is to use the <a class="el" href="group__wpcapfunc.html#ga14">pcap_next_ex()</a> function, which is presented in the next example (<a class="el" href="group__wpcap__tut4.html">Capturing the packets without the callback</a>).<p>
<a class="el" href="group__wpcap__tut2.html">&lt;&lt;&lt; Previous</a> <a class="el" href="group__wpcap__tut4.html">Next &gt;&gt;&gt;</a> 
<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2005 Politecnico di Torino. Copyright (c) 2005 
CACE technologies. All rights reserved.</p>
